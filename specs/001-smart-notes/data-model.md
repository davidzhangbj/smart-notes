# Data Model: Smart Notes Application

**Feature**: Smart Notes Application (001-smart-notes)
**Date**: 2026-02-12
**Database**: seekdb embedded (pyseekdb)

---

## Overview

Smart Notes uses seekdb's collection-based data model. A single collection stores all notes with tags represented as metadata fields. The collection uses seekdb's built-in embedding function for automatic vectorization.

---

## Collection: `notes`

### Purpose

Store all user notes with full-text search and semantic search capabilities.

### Structure

| Field | Type | Required | Description | Index |
|-------|------|----------|-------------|-------|
| `id` | string | Yes | Unique note identifier (UUID) | Primary |
| `title` | string | No | Note title (max 200 chars) | Full-text |
| `content` | string | Yes | Note body in Markdown | Full-text |
| `tags` | list[string] | No | Tag names for filtering | Metadata |
| `created_at` | int64 | Yes | Unix timestamp (creation) | Metadata |
| `updated_at` | int64 | Yes | Unix timestamp (last update) | Metadata |
| `_embedding` | vector | Auto | Auto-generated vector | Vector (HNSW) |

### seekdb Mapping

```python
# Document (what search operates on)
document = f"{title}\n\n{content}" if title else content

# Metadata (what filters operate on)
metadata = {
    "tags": tags,           # List of tag strings
    "created_at": created_at,
    "updated_at": updated_at
}

# Vector (auto-generated by embedding function)
# _embedding = embedding_function(document)
```

### Validation Rules

| Field | Rule | Enforcement |
|-------|------|-------------|
| `id` | Valid UUID format | Python code |
| `title` | Max 200 characters | Python code |
| `content` | Max 100,000 characters | Python code |
| `tags` | Max 20 tags per note | Python code |
| `tags` | Each tag max 50 characters | Python code |
| `created_at` | Non-negative integer | Python code |
| `updated_at` | >= created_at | Python code |

---

## State Transitions

### Note Lifecycle

```
┌─────────┐     update     ┌─────────┐     delete     ┌─────────┐
│  Draft  │ ──────────────> │ Saved   │ ─────────────> │ Deleted │
│ (local) │                │ (stored) │                │ (gone)  │
└─────────┘                └─────────┘                └─────────┘
     ^                          │
     │                          │ select
     └──────────────────────────┘
```

### States

| State | Description | Transitions |
|-------|-------------|-------------|
| `new` | Note created but not yet saved | → `saved` |
| `saved` | Note persisted in database | → `saved` (update), `deleted` |
| `deleted` | Note removed from database | (terminal) |

---

## Index Design

### Full-Text Index

Automatically created by seekdb on the document field:

```
Document = title + "\n\n" + content
```

**Purpose**: Fast keyword search (FR-012)

### Vector Index (HNSW)

Automatically created by seekdb on the `_embedding` field:

```
Embedding = embedding_function(Document)
```

**Purpose**: Fast semantic search (FR-013)

**Configuration**:
- Type: HNSW (Hierarchical Navigable Small World)
- Distance: Cosine similarity
- Performance: <100ms for 1000 notes

---

## Tag Storage

### Design Decision

Store tags as a metadata field (list of strings) rather than separate collection.

**Rationale**:
- Single-user app: No need for normalized tag table
- Simple filtering: `where={"tags": {"$in": ["work"]}}`
- No join complexity
- Tags always used in context of notes

### Tag Uniqueness

Tag names are case-sensitive for display but normalized for search:

```
"Work" != "work"  # Different tags for display
```

**Trade-off**: Simplicity over automatic deduplication. Users can create similar tags intentionally.

---

## Query Patterns

### 1. List All Notes

```python
results = collection.get(
    limit=100,
    include=["documents", "metadatas"],
    where={},  # No filter
)
# Order by updated_at desc (application side)
```

### 2. Get Note by ID

```python
results = collection.get(
    ids=["note_id"],
    include=["documents", "metadatas"],
)
```

### 3. Search Notes (Hybrid)

```python
results = collection.hybrid_search(
    query={
        "where_document": {"$contains": query},  # Keyword match
        "n_results": 50
    },
    knn={
        "query_texts": [query],  # Semantic match
        "n_results": 50
    },
    rank={"rrf": {}},  # Combine results
    n_results=20
)
```

### 4. Filter by Tag

```python
results = collection.get(
    where={"tags": {"$in": ["work"]}},
    include=["documents", "metadatas"],
    limit=100,
)
```

### 5. Search within Tag

```python
results = collection.hybrid_search(
    query={
        "where_document": {"$contains": query},
        "where": {"tags": {"$in": ["work"]}},  # Tag filter
        "n_results": 50
    },
    knn={
        "query_texts": [query],
        "where": {"tags": {"$in": ["work"]}},  # Tag filter
        "n_results": 50
    },
    rank={"rrf": {}},
    n_results=20
)
```

---

## Data Operations

### Create Note

```python
id = str(uuid.uuid4())
now = int(time.time())

collection.add(
    ids=[id],
    documents=[content],  # title prepended by app
    metadatas=[{
        "tags": tags,
        "created_at": now,
        "updated_at": now
    }]
)
```

### Update Note

```python
now = int(time.time())

collection.update(
    ids=[id],
    documents=[new_content],
    metadatas=[{
        "tags": new_tags,
        "created_at": old_created_at,  # Preserve
        "updated_at": now
    }]
)
```

### Delete Note

```python
collection.delete(ids=[id])
```

---

## Storage Estimation

### Per-Note Storage

| Component | Size | Notes |
|-----------|------|-------|
| ID | 36 bytes | UUID string |
| Title | ~50 bytes | Average |
| Content | ~2000 bytes | Average note |
| Tags | ~100 bytes | 5 tags × 20 chars |
| Timestamps | 16 bytes | 2 × int64 |
| Embedding | ~1024 bytes | 256-dim vector (float32) |
| **Total** | **~3.2 KB** | Per note |

### Scale Estimates

| Notes | Storage | Search Time (est.) |
|-------|---------|-------------------|
| 100 | ~320 KB | <10ms |
| 1,000 | ~3.2 MB | <50ms |
| 10,000 | ~32 MB | <100ms |

---

## Data Migration & Export

### Export Format

JSON export for portability:

```json
{
  "version": "1.0",
  "exported_at": 1736707200,
  "notes": [
    {
      "id": "uuid",
      "title": "Note Title",
      "content": "# Markdown content",
      "tags": ["work", "important"],
      "created_at": 1736700000,
      "updated_at": 1736707200
    }
  ]
}
```

### Import

```python
for note in json_data["notes"]:
    collection.add(
        ids=[note["id"]],
        documents=[note["content"]],
        metadatas=[{
            "tags": note["tags"],
            "created_at": note["created_at"],
            "updated_at": note["updated_at"]
        }]
    )
```

---

## References

- [pyseekdb Client API](https://raw.githubusercontent.com/oceanbase/seekdb-doc/V1.1.0/en-US/450.reference/900.sdk/10.pyseekdb-sdk/50.apis/50.client.md)
- [hybrid_search API](https://raw.githubusercontent.com/oceanbase/seekdb-doc/V1.1.0/en-US/450.reference/900.sdk/10.pyseekdb-sdk/50.apis/400.dql/400.hybrid-search-of-api.md)
- [Collection Operations](https://raw.githubusercontent.com/oceanbase/seekdb-doc/V1.1.0/en-US/450.reference/900.sdk/10.pyseekdb-sdk/50.apis/200.collection/100.create-collection-of-api.md)
